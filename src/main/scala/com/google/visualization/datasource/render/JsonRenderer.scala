package com.google.visualization.datasource.render

import com.google.common.collect.Lists
import com.google.visualization.datasource.base._
import com.google.visualization.datasource.datatable._
import com.google.visualization.datasource.datatable.value._
import com.ibm.icu.util.{Calendar, GregorianCalendar}
import org.apache.commons.lang.StringUtils
import org.apache.commons.lang.text.StrBuilder
import java.{util=>ju}
import math.abs
import collection.JavaConverters._

import org.apache.commons.logging.Log
import org.apache.commons.logging.LogFactory

import EscapeUtil.{jsonEscape => esc}


/**
 * Takes a data table and returns a json string.
 *
 * @author Nimrod T.
 */
object JsonRenderer {
  private val log = LogFactory.getLog(this.getClass)

//  /**
//   * Returns a String-form 32-bit hash of this table's json.
//   * Note: the signature ignores formatting.
//   *
//   * @param data The data table.
//   *
//   * @return a String-form 64-bit hash of this table.
//   */
//  def getSignature(data: DataTable) =
//    abs(renderDataTable(data, true, false).toString.hashCode.toLong).toString

  /**
   * Returns the part of the json string that describes a single warning or error.
   *
   * @param reasonType The reason for the warning or error.
   * @param description The detailed description for this warning or error.
   *
   * @return The part of the json string.
   */
  private def faultString(reasonType: ReasonType, description: String) = {
    val objectParts = Seq.newBuilder[String]
    Option(reasonType) foreach { rt =>
      objectParts += "reason:'%s'".format(rt.lowerCaseString)
      objectParts += "message:'%s'".format(esc(rt.getMessageForReasonType(null)))
    }
    Option(description) foreach { d =>
      objectParts += "detailed_message:'%s'".format(esc(d))
    }
    val op = objectParts.result
    if (op.isEmpty) null else op.mkString("{", ",", "}")
  }

  /**
   * Returns the json response for the given data table.
   *
   * @param dsParams
   *   The datasource parameters (autogenerated tqx= in the query string.
   * @param responseStatus
   *   The response status.
   * @param data
   *   The data table.
   *
   * @return The json response for the given data table and parameters.
   */
  def renderJsonResponse(dsParams: DataSourceParameters, responseStatus0: ResponseStatus, data: DataTable): CharSequence = {
    val isJsonp = dsParams.getOutputType == OutputType.JSONP

    log info "rendering JSON"
    import StatusType._
    var responseStatus = responseStatus0
    val sb = new StrBuilder

    if (isJsonp) {
      sb append dsParams.getResponseHandler append "("
    }
    sb append "{version:'0.6'"
    Option(dsParams.getRequestId) foreach { param =>
      sb append ",reqId:'%s'".format(esc(param))
    }
    val previousSignature = dsParams.getSignature
//    if (responseStatus == null) {
//      responseStatus =
//        if (!StringUtils.isEmpty(previousSignature) && data != null && getSignature(data) == previousSignature)
//          new ResponseStatus(StatusType.ERROR, ReasonType.NOT_MODIFIED, null)
//        else
//          new ResponseStatus(StatusType.OK, null, null)
//    }
    responseStatus = Option(responseStatus0) getOrElse {new ResponseStatus(StatusType.OK, null, null)}
    val statusType = responseStatus.getStatusType
    sb append ",status:'%s'".format(statusType.lowerCaseString)
    statusType match {
      case OK =>
      case WARNING =>
        val warnings = Option(data.getWarnings) map (_.asScala) flatten
        val warningJsonStrings = warnings map { w => faultString(w.getReasonType, w.getMessage) }
        if (!warnings.isEmpty)
          sb append warningJsonStrings.mkString(",warnings:[", ",", "]")
      case _ =>
        sb append ",errors:[%s]".format(faultString(responseStatus.getReasonType, responseStatus.getDescription))
        sb append "]"
    }
    if (statusType != ERROR && data != null) {
//      sb append ",sig:'%s'".format(getSignature(data))
      sb append ",table:" + JsonRenderer.renderDataTable(data, true, true)
    }
    sb append "}"
    if (isJsonp) { sb append ");" }
    log info "JSON generation complete"

    sb.toString
  }

  def renderDataTable(dataTable: DataTable, includeValues: Boolean, includeFormatting: Boolean): CharSequence = {
    if (dataTable.getColumnDescriptions.isEmpty) {
      return ""
    }
    val columnDescriptions = dataTable.getColumnDescriptions.asScala.toSeq
    val sb = new StringBuilder
    sb append "{"

    sb append (columnDescriptions map columnDescriptionJson).mkString("cols:[", ",", "]")

    if (includeValues) {
      sb.append(",rows:[")
      var columnDescription: ColumnDescription = null
      var rows = dataTable.getRows.asScala.iterator

      rows foreach { tableRow =>
        sb append "{c:["
        val cells = tableRow.getCells.asScala.iterator
        cells foreach { cell =>
          sb.append(
            if (cells.hasNext) cellJson(cell, includeFormatting, false) + ","
            else cellJson(cell, includeFormatting, true)
          )
        }
        sb append "]"
        sb append propertiesMapJson(tableRow.getCustomProperties)
        sb append "}"
        if (rows.hasNext) sb.append(",")
      }
      sb append "]"
    }
    sb append propertiesMapJson(dataTable.getCustomProperties)
    sb append "}"
  }

  def cellJson(cell: TableCell, includeFormatting: Boolean, isLastColumn: Boolean) = {
    import ValueType._
    val value = cell.getValue
    val valueType = cell.getType
    var isJsonNull = value == null || value.isNull

    val json =
      if (isJsonNull) "null" else valueType match {
        case BOOLEAN =>
          value.asInstanceOf[BooleanValue].getValue
        case DATE =>
          val dateValue = value.asInstanceOf[DateValue]
          import dateValue._
          "new Date(%d,%d,%d)".format(getYear, getMonth, getDayOfMonth)
        case NUMBER =>
          value.asInstanceOf[NumberValue].getValue
        case TEXT =>
          "'" +  esc(value.toString) + "'"
        case TIMEOFDAY =>
          val timeOfDayValue = value.asInstanceOf[TimeOfDayValue]
          import timeOfDayValue._
          "[%d,%d,%d,%d]".format(getHours, getMinutes, getSeconds, getMilliseconds)
        case DATETIME =>
          val calendar = (value.asInstanceOf[DateTimeValue]).getCalendar
          import Calendar._
          "new Date(%d,%d,%d,%d,%d,%d)".format(
            calendar.get(YEAR),
            calendar.get(MONTH),
            calendar.get(DAY_OF_MONTH),
            calendar.get(HOUR_OF_DAY),
            calendar.get(MINUTE),
            calendar.get(SECOND)
          )
        case vt =>
          throw new IllegalArgumentException("Illegal value Type " + vt)
      }

    val formattedValue = cell.getFormattedValue

    val isNonNull = (value != null) && !value.isNull && (formattedValue != null)
    val escapedFormattedString =
      if (isNonNull && (valueType != ValueType.TEXT || value.toString != formattedValue))
        esc(formattedValue)
      else ""

    // Add a Json for this cell. And,
    // 1) If the formatted value is empty drop it.
    // 2) If the value is null, and it is not the last column in the row drop the entire Json.
    if (isLastColumn || !isJsonNull) {
      val formatting =
        if (includeFormatting && !escapedFormattedString.isEmpty)
          ",f:'%s'".format(escapedFormattedString)
        else ""

      "{v:%s%s%s}".format(
        json,
        formatting,
        propertiesMapJson(cell.getCustomProperties)
      )
    } else ""
  }

  def columnDescriptionJson(col: ColumnDescription) = {
    "{id:'%s',label:'%s',type:'%s',pattern:'%s'%s}".format(
      esc(col.getId),
      esc(col.getLabel),
      col.getType.getTypeCodeLowerCase,
      esc(col.getPattern),
      propertiesMapJson(col.getCustomProperties)
    )
  }

  private def propertiesMapString(propertiesMap: Map[String, String]): String = {
    propertiesMap map { case (k,v) => "'%s':'%s'".format(esc(k), esc(v))
    } mkString("{", ",", "}")
  }

  private def propertiesMapJson(propertiesMap: ju.Map[String, String]): String =
    Option(propertiesMap) map (_.asScala.toMap) filter (!_.isEmpty) map {",p:" + propertiesMapString(_)} getOrElse ""

}
