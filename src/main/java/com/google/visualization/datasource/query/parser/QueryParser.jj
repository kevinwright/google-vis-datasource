// Copyright 2009 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * Specification for query parser for javacc.
 *
 * @author Yonatan B.Y.
 */

options {
  STATIC=false;
  JAVA_UNICODE_ESCAPE=true;
}

PARSER_BEGIN(QueryParser)

package com.google.visualization.datasource.query.parser;

import com.google.visualization.datasource.base.InvalidQueryException;
import com.google.visualization.datasource.datatable.value.BooleanValue;
import com.google.visualization.datasource.datatable.value.NumberValue;
import com.google.visualization.datasource.datatable.value.TextValue;
import com.google.visualization.datasource.datatable.value.Value;
import com.google.visualization.datasource.query.AbstractColumn;
import com.google.visualization.datasource.query.AggregationColumn;
import com.google.visualization.datasource.query.AggregationType;
import com.google.visualization.datasource.query.ColumnColumnFilter;
import com.google.visualization.datasource.query.ColumnIsNullFilter;
import com.google.visualization.datasource.query.ColumnValueFilter;
import com.google.visualization.datasource.query.ComparisonFilter;
import com.google.visualization.datasource.query.CompoundFilter;
import com.google.visualization.datasource.query.NegationFilter;
import com.google.visualization.datasource.query.Query;
import com.google.visualization.datasource.query.QueryFilter;
import com.google.visualization.datasource.query.QueryFormat;
import com.google.visualization.datasource.query.QueryGroup;
import com.google.visualization.datasource.query.QueryLabels;
import com.google.visualization.datasource.query.QueryOptions;
import com.google.visualization.datasource.query.QueryPivot;
import com.google.visualization.datasource.query.QuerySelection;
import com.google.visualization.datasource.query.QuerySort;
import com.google.visualization.datasource.query.ScalarFunctionColumn;
import com.google.visualization.datasource.query.SortOrder;
import com.google.visualization.datasource.query.SimpleColumn;
import com.google.visualization.datasource.query.scalarfunction.Constant;
import com.google.visualization.datasource.query.scalarfunction.CurrentDateTime;
import com.google.visualization.datasource.query.scalarfunction.DateDiff;
import com.google.visualization.datasource.query.scalarfunction.Difference;
import com.google.visualization.datasource.query.scalarfunction.Lower;
import com.google.visualization.datasource.query.scalarfunction.Modulo;
import com.google.visualization.datasource.query.scalarfunction.Product;
import com.google.visualization.datasource.query.scalarfunction.Quotient;
import com.google.visualization.datasource.query.scalarfunction.ScalarFunction;
import com.google.visualization.datasource.query.scalarfunction.Sum;
import com.google.visualization.datasource.query.scalarfunction.ToDate;
import com.google.visualization.datasource.query.scalarfunction.TimeComponentExtractor;
import com.google.visualization.datasource.query.scalarfunction.Upper;

import java.io.BufferedReader;
import java.io.Reader;
import java.io.StringReader;
import java.util.ArrayList;

/**
 *  Query parser.  AUTOGENERATED, see QueryParser.jj
 */
public class QueryParser {

  public static Query parseString(String queryString)
      throws ParseException, InvalidQueryException {
    Reader r = new BufferedReader(new StringReader(queryString));
    QueryParser parser = new QueryParser(r);
    Query query = parser.queryStatement();
    return query;
  }
}



PARSER_END(QueryParser)

SKIP:
{
    " "
  | "\t"
  | "\n"
  | "\r"
}

// keywords that cannot be used as column ids
TOKEN[IGNORE_CASE]:
{
    <KW_SELECT:       "select">
  | <KW_WHERE:        "where">
  | <KW_GROUP:        "group">
  | <KW_PIVOT:        "pivot">
  | <KW_ORDER:        "order">
  | <KW_BY:           "by">
  | <KW_SKIPPING:     "skipping">
  | <KW_LIMIT:        "limit">
  | <KW_OFFSET:       "offset">
  | <KW_LABEL:        "label">
  | <KW_FORMAT:       "format">
  | <KW_OPTIONS:      "options">
  | <KW_ASC:          "asc">
  | <KW_DESC:         "desc">
  | <KW_TRUE:         "true">
  | <KW_FALSE:        "false">
  | <KW_AND:          "and">
  | <KW_OR:           "or">
  | <KW_NOT:          "not">
  | <KW_DATE:         "date">
  | <KW_TIMEOFDAY:    "timeofday">
  | <KW_DATETIME:     "datetime">
  | <KW_TIMESTAMP:    "timestamp">
}

// keywords that can be used as column ids
TOKEN[IGNORE_CASE]:
{
    <KW_MIN:          "min">
  | <KW_MAX:          "max">
  | <KW_AVG:          "avg">
  | <KW_COUNT:        "count">
  | <KW_SUM:          "sum">
  | <KW_NO_VALUES:    "no_values">
  | <KW_NO_FORMAT:    "no_format">
  | <KW_IS:           "is">
  | <KW_NULL:         "null">
  | <KW_YEAR:         "year">
  | <KW_MONTH:        "month">
  | <KW_DAY:          "day">
  | <KW_HOUR:         "hour">
  | <KW_MINUTE:       "minute">
  | <KW_SECOND:       "second">
  | <KW_MILLISECOND:  "millisecond">
  | <KW_WITH:         "with">
  | <KW_CONTAINS:     "contains">
  | <KW_STARTS:       "starts">
  | <KW_ENDS:         "ends">
  | <KW_MATCHES:      "matches">
  | <KW_LIKE:         "like">
  | <KW_NOW:          "now">
  | <KW_DATEDIFF:     "dateDiff">
  | <KW_QUARTER:      "quarter">
  | <KW_LOWER:        "lower">
  | <KW_UPPER:        "upper">
  | <KW_DAYOFWEEK:    "dayOfWeek">
  | <KW_TODATE:       "toDate">
}

// literals
TOKEN:
{
    <ID: <LETTER_OR_UNDERSCORE> ( <ALPHANUMERIC> )* >
  | <INTEGER_LITERAL: (<DIGIT>)+ > // For use in LIMIT, OFFSET, ...
  | <DECIMAL_LITERAL:
      ( ( (<DIGIT>)+ "." (<DIGIT>)* )
             | ( "." (<DIGIT>)+ ) )
    >
  | <#ALPHANUMERIC: <DIGIT> | <LETTER_OR_UNDERSCORE> >
  | <#DIGIT: ["0"-"9"] >
  | <#LETTER_OR_UNDERSCORE: ["a"-"z","A"-"Z","_"] >
  | <STRING_LITERAL:
        "'" (~["'"])* "'"
      | "\"" (~["\""])* "\"" >
  | <QUOTED_ID: "`" (~["`"])+ "`" >
}

// operators
TOKEN:
{
    <OP_COMMA:             ",">
  | <OP_LPAREN:            "(">
  | <OP_RPAREN:            ")">
  | <OP_EQUALS:            "=">
  | <OP_NOT_EQUALS:        "!=" | "<>">
  | <OP_LESS_THAN:         "<">
  | <OP_LESS_OR_EQUAL:     "<=">
  | <OP_GREATER_THAN:      ">">
  | <OP_GREATER_OR_EQUAL:  ">=">
  | <OP_ASTERISK:          "*">
  | <OP_PLUS:              "+">
  | <OP_MINUS:             "-">
  | <OP_SLASH:             "/">
  | <OP_MODULO:            "%">
}

// The entire query
Query queryStatement() throws InvalidQueryException :
{
  Query query = new Query();
}
{
  (
      [ selectClause(query) ]
      [ whereClause(query) ]
      [ groupByClause(query) ]
      [ pivotClause(query) ]
      [ orderByClause(query) ]
      [ skippingClause(query) ]
      [ limitClause(query) ]
      [ offsetClause(query) ]
      [ labelClause(query) ]
      [ formatClause(query) ]
      [ optionsClause(query) ]
      <EOF>
  )
  {return query; }
}

// The select clause (e.g., SELECT c1, c2)
void selectClause(Query query) throws InvalidQueryException :
{
  QuerySelection selection = new QuerySelection();
  AbstractColumn column;
}
{
  <KW_SELECT>
  ( (column = abstractColumnDescriptor()
     { selection.addColumn(column); }
     (<OP_COMMA> column = abstractColumnDescriptor()
         { selection.addColumn(column); } )*
     { query.setSelection(selection); } )
   | <OP_ASTERISK> ) // do nothing
}

// The where clause (e.g., WHERE (c1 > 3) AND (NOT(c3 <= c4)))
void whereClause(Query query) throws InvalidQueryException :
{
  QueryFilter filter;
}
{
  <KW_WHERE>
  filter = logicalExpression()
  { query.setFilter(filter); }
}

// The group by clause (e.g. GROUP BY c1, c2)
void groupByClause(Query query) throws InvalidQueryException :
{
  QueryGroup group = new QueryGroup();
  AbstractColumn column;
}
{
  <KW_GROUP>
  <KW_BY>
  column = abstractColumnDescriptor()
  { group.addColumn(column); }
  (<OP_COMMA> column = abstractColumnDescriptor()
      { group.addColumn(column); } )*
  { query.setGroup(group); }
}

// The pivot clause (e.g. PIVOT c1, c2)
void pivotClause(Query query) throws InvalidQueryException :
{
  QueryPivot pivot = new QueryPivot();
  AbstractColumn column;
}
{
  <KW_PIVOT>
  column = abstractColumnDescriptor()
  { pivot.addColumn(column); }
  (<OP_COMMA> column = abstractColumnDescriptor()
      { pivot.addColumn(column); } )*
  { query.setPivot(pivot); }
}

// The order by clause (e.g., ORDER BY c1, c2 ASC, c3 DESC)
void orderByClause(Query query) throws InvalidQueryException :
{
  QuerySort sort = new QuerySort();
  AbstractColumn column;
  SortOrder order;
}
{
  <KW_ORDER>
  <KW_BY>
  column = abstractColumnDescriptor()
  order = sortOrder()
  { sort.addSort(column, order); }
  (<OP_COMMA> column = abstractColumnDescriptor() order = sortOrder()
    { sort.addSort(column, order); } )*
  { query.setSort(sort); }
}

// The skipping clause (e.g., SKIPPING 10)
void skippingClause(Query query) throws InvalidQueryException :
{
  int skipping;
}
{
  <KW_SKIPPING>
  skipping = integerLiteral()
  { query.setRowSkipping(skipping); }
}

// The limit clause (e.g., LIMIT 100)
void limitClause(Query query) throws InvalidQueryException :
{
  int limit;
}
{
  <KW_LIMIT>
  limit = integerLiteral()
  { query.setRowLimit(limit); }
}

// The offset clause (e.g., OFFSET 100)
void offsetClause(Query query) throws InvalidQueryException :
{
  int offset;
}
{
  <KW_OFFSET>
  offset = integerLiteral()
  { query.setRowOffset(offset); }
}

// The label clause (e.g., LABEL c1 "Department", c3 "Salary")
void labelClause(Query query) throws InvalidQueryException :
{
  QueryLabels labels = new QueryLabels();
  AbstractColumn column;
  String label;
}
{
  <KW_LABEL>
  column = abstractColumnDescriptor()
  label = stringLiteral()
  { labels.addLabel(column, label); }
  (<OP_COMMA> column = abstractColumnDescriptor() label = stringLiteral()
    { labels.addLabel(column, label); } )*
  { query.setLabels(labels); }
}

// The format clause (e.g., FORMAT c1 "#", c3 "dd-MM-YYYY")
void formatClause(Query query) throws InvalidQueryException :
{
  QueryFormat formats = new QueryFormat();
  AbstractColumn column;
  String pattern;
}
{
  <KW_FORMAT>
  column = abstractColumnDescriptor()
  pattern = stringLiteral()
  { formats.addPattern(column, pattern); }
  (<OP_COMMA> column = abstractColumnDescriptor() pattern = stringLiteral()
    { formats.addPattern(column, pattern); } )*
  { query.setUserFormatOptions(formats); }
}

// The options clause (e.g., OPTIONS no_format)
void optionsClause(Query query) :
{
  QueryOptions queryOptions = new QueryOptions();
  QueryOptionEnum optionEnum;
}
{
  <KW_OPTIONS>
  (
    optionEnum = queryOption()
    { optionEnum.setInQueryOptions(queryOptions); }
  )+
  { query.setOptions(queryOptions); }
}

// a logical expression, e.g., c1 > c2 or not c1 < 3 and (c3 >= c4)
// currently implemented as simply a call to possibleOrExpression
QueryFilter logicalExpression() throws InvalidQueryException :
{
  QueryFilter filter;
}
{
    filter = possibleOrExpression()
    { return filter; }
}

// A possible OR expression, i.e., an OR of several possible AND expressions.
// It is "possible" because it can also match a single expression without any
// ORs and then it is just returned as is.
QueryFilter possibleOrExpression() throws InvalidQueryException :
{
  ArrayList subFilters = new ArrayList();
  QueryFilter filter;
}
{
    filter = possibleAndExpression()
    { subFilters.add(filter); }
    ( <KW_OR> filter = possibleAndExpression() { subFilters.add(filter); } )*
    {
      if (subFilters.size() == 1) {
        return (QueryFilter)subFilters.get(0);
      } else {
        return new CompoundFilter(
            CompoundFilter.LogicalOperator.OR,
            GenericsHelper.makeTypedList(subFilters));
      }
    }
}

// A possible AND expression, i.e., an AND of several possible NOT expressions.
// It is "possible" because it can also match a single expression without any
// ANDs and then it is just returned as is.
QueryFilter possibleAndExpression() throws InvalidQueryException :
{
  ArrayList subFilters = new ArrayList();
  QueryFilter filter;
}
{
    filter = possibleNotExpression()
    { subFilters.add(filter); }
    ( <KW_AND> filter = possibleNotExpression() { subFilters.add(filter); } )*
  {
    if (subFilters.size() == 1) {
      return (QueryFilter)subFilters.get(0);
    } else {
      return new CompoundFilter(
          CompoundFilter.LogicalOperator.AND,
          GenericsHelper.makeTypedList(subFilters));
    }
  }
}

// A primary expression, with an optional NOT
QueryFilter possibleNotExpression() throws InvalidQueryException :
{
  QueryFilter subFilter;
  QueryFilter filter;
}
{

  ( (<KW_NOT> subFilter = primaryExpression()
      { filter = new NegationFilter(subFilter); })
  | (subFilter = primaryExpression()
      { filter = subFilter; }) )
  { return filter; }
}

// A primary expression, i.e., a binary comparison operator between two operands
// or an expression in parentheses.
QueryFilter primaryExpression() throws InvalidQueryException :
{
  QueryFilter filter;
}
{
  ( LOOKAHEAD(primitiveFilter()) (filter = primitiveFilter())
  | (<OP_LPAREN> filter = logicalExpression() <OP_RPAREN>) )
  { return filter; }
}

// A comparison expression, i.e., a binary comparison operator between two
// operands that may be literals or column ids. Or an IS NULL or IS NOT NULL.
QueryFilter primitiveFilter() throws InvalidQueryException :
{
  QueryFilter filter;
  AbstractColumn col1;
  AbstractColumn col2;
  ComparisonFilter.Operator op;
  Value val;
}
{
  ( LOOKAHEAD(literal()) ( val = literal() op = comparisonOperator()
    col1 = abstractColumnDescriptor()
    { filter = new ColumnValueFilter(col1, val, op, true); } )
  | ( col1 = abstractColumnDescriptor()
      ( (<KW_IS>
          ( (<KW_NULL>
              { filter = new ColumnIsNullFilter(col1); } )
          | (<KW_NOT> <KW_NULL>
              { filter = new NegationFilter(new ColumnIsNullFilter(col1)); }
            )
          )
        )
      | (op = comparisonOperator()
          ( LOOKAHEAD(literal()) ( val =  literal()
            { filter = new ColumnValueFilter(col1, val, op, false); } )
          | ( col2 = abstractColumnDescriptor()
              { filter = new ColumnColumnFilter(col1, col2, op); }
            )
          )
        )
      )
    )
  )
  { return filter; }
}

// A comparison operator, i.e., one of <, >, =, !=, <>, <=, >= and maybe others.
ComparisonFilter.Operator comparisonOperator() :
{
  ComparisonFilter.Operator op;
}
{
  ( (<OP_EQUALS> { op = ComparisonFilter.Operator.EQ; })
  | (<OP_NOT_EQUALS> { op = ComparisonFilter.Operator.NE; })
  | (<OP_LESS_THAN> { op = ComparisonFilter.Operator.LT; })
  | (<OP_LESS_OR_EQUAL> { op = ComparisonFilter.Operator.LE; })
  | (<OP_GREATER_THAN> { op = ComparisonFilter.Operator.GT; })
  | (<OP_GREATER_OR_EQUAL> { op = ComparisonFilter.Operator.GE; })
  | (<KW_CONTAINS> { op = ComparisonFilter.Operator.CONTAINS; })
  | (<KW_STARTS> <KW_WITH> { op = ComparisonFilter.Operator.STARTS_WITH; })
  | (<KW_ENDS> <KW_WITH> { op = ComparisonFilter.Operator.ENDS_WITH; })
  | (<KW_MATCHES> { op = ComparisonFilter.Operator.MATCHES; })
  | (<KW_LIKE> { op = ComparisonFilter.Operator.LIKE; }) )
  { return op; }
}

// A literal. Corresponds to a value on the server, i.e., can be of one of the
// following types: string, number, boolean, date, timeOfDay, dateTime.
Value literal() throws InvalidQueryException :
{
  Value val;
  String str;
  double num;
  boolean bool;
  String dateStr; // Used for date, timeofday and timestamp.
}
{
  ( (str = stringLiteral() { val = new TextValue(str); })
  | (num = decimalLiteral() { val = new NumberValue(num); })
  | (bool = booleanLiteral() { val = BooleanValue.getInstance(bool); })
  | (<KW_DATE> dateStr = stringLiteral()
      { val = ParserUtils.stringToDate(dateStr); })
  | (<KW_TIMEOFDAY> dateStr = stringLiteral()
      { val = ParserUtils.stringToTimeOfDay(dateStr); })
  | ((<KW_DATETIME> | <KW_TIMESTAMP>) dateStr = stringLiteral()
      { val = ParserUtils.stringToDatetime(dateStr); }) )
  { return val; }
}

// A single query option (e.g., no_format)
QueryOptionEnum queryOption() :
{
  QueryOptionEnum result = null;
}
{
  ( (<KW_NO_VALUES> { result = QueryOptionEnum.NO_VALUES; })
  | (<KW_NO_FORMAT> { result = QueryOptionEnum.NO_FORMAT; }) )
  { return result; }
}

// An abstract column descriptor, i.e., either a column id, an aggregation
// function name followed by parentheses with column id (e.g., max(c1)) or a
// scalar function followed by parentheses with abstract columns
// (e.g., curr_time(), year(d1), year(sum(c1)), month(c2)), ....
AbstractColumn abstractColumnDescriptor() throws InvalidQueryException :
{
  AbstractColumn column;
  AbstractColumn result = null;
}
{
  ( LOOKAHEAD(2) ( column = arithmeticExpression() { result = column; } )
  | ( column = atomicAbstractColumnDescriptor() { result = column; } ) )
  { return result; }
}

// An atomic abstract column descriptor, i.e., the same as abstract column,
// except it does not include arithmetic expressions like: c1+c2/c3*(c4+c5).
AbstractColumn atomicAbstractColumnDescriptor() throws InvalidQueryException :
{
  AggregationType aggregationType;
  ScalarFunction scalarFunction;
  String columnId;
  AbstractColumn column;
  ArrayList columns = new ArrayList();
  AbstractColumn result = null;
  Value value;
}
{
  // The lookahead is to tell between min and min(c1).
  ( LOOKAHEAD(2) (aggregationType = aggregationFunction() <OP_LPAREN>
     columnId = columnId() <OP_RPAREN>
     { result = new AggregationColumn(new SimpleColumn(columnId),
           aggregationType); } )
   | LOOKAHEAD(2) ( scalarFunction = scalarFunction() <OP_LPAREN>
       (column = abstractColumnDescriptor() { columns.add(column); })?
       (<OP_COMMA> column = abstractColumnDescriptor()
          { columns.add(column); })* <OP_RPAREN>
          { result = new ScalarFunctionColumn(
              GenericsHelper.makeTypedList(columns), scalarFunction); } )
   | ( <OP_LPAREN> column = abstractColumnDescriptor() <OP_RPAREN>
       { result = column; } )
   | ( value = literal()
       { result = new ScalarFunctionColumn(new ArrayList(),
           new Constant(value)); } )
   | ( columnId = columnId() { result = new SimpleColumn(columnId); } ) )
  { return result; }
}

// An arithmetic expression, e.g., c1 + c2 / c1 * 3 - (c3 + c4).
AbstractColumn arithmeticExpression() throws InvalidQueryException :
{
  AbstractColumn column;
}
{
  column = possibleSecondOrderArithmeticExpression()
  { return column; }
}

// A possible sum or subtraction expression of possible multiplication or division expressions.
// It is "possible" because it can also match a single expression without any
// multiplications and divisions, and then it is just returned as is.
AbstractColumn possibleSecondOrderArithmeticExpression() throws
    InvalidQueryException :
{
  AbstractColumn column;
  AbstractColumn column1;
}
{
  column = possibleFirstOrderArithmeticExpression()
  (
  ( (<OP_PLUS> column1 = possibleFirstOrderArithmeticExpression() {
    column =
      new ScalarFunctionColumn(GenericsHelper.makeAbstractColumnList(
          new AbstractColumn[] {column, column1}), Sum.getInstance() );} )
  | (<OP_MINUS> column1 = possibleFirstOrderArithmeticExpression() {
    column =
      new ScalarFunctionColumn(GenericsHelper.makeAbstractColumnList(
          new AbstractColumn[]{column, column1}),
          Difference.getInstance()); } ) ) )*
  { return column; }
}

// A possible multiplication division or modulo expression of atomic abstract column descriptors.
AbstractColumn possibleFirstOrderArithmeticExpression() throws
    InvalidQueryException :
{
  AbstractColumn column;
  AbstractColumn column1;
}
{
  column = atomicAbstractColumnDescriptor()
  (
  ( (<OP_ASTERISK> column1 = atomicAbstractColumnDescriptor() {
    column =
      new ScalarFunctionColumn(GenericsHelper.makeAbstractColumnList(
          new AbstractColumn[] {column, column1}), Product.getInstance() );} )
  | (<OP_SLASH> column1 = atomicAbstractColumnDescriptor() {
    column =
      new ScalarFunctionColumn(GenericsHelper.makeAbstractColumnList(
          new AbstractColumn[]{column, column1}),
          Quotient.getInstance()); } )
  | (<OP_MODULO> column1 = atomicAbstractColumnDescriptor() {
    column =
      new ScalarFunctionColumn(GenericsHelper.makeAbstractColumnList(
          new AbstractColumn[]{column, column1}),
          Modulo.getInstance()); } ) ) )*
  { return column; }
}

// An aggregation function, e.g., "max", "avg", ...
AggregationType aggregationFunction() :
{
  AggregationType result = null;
}
{
  ( (<KW_MIN> { result = AggregationType.MIN; } )
  | (<KW_MAX> { result = AggregationType.MAX; } )
  | (<KW_COUNT> { result = AggregationType.COUNT; } )
  | (<KW_AVG> { result = AggregationType.AVG; } )
  | (<KW_SUM> { result = AggregationType.SUM; } ) )
  { return result; }
}

// A scalar function, e.g., "datediff", "upper".
ScalarFunction scalarFunction() :
{
  ScalarFunction result = null;
}
{
  ( (<KW_YEAR> { result = TimeComponentExtractor.getInstance(
          TimeComponentExtractor.TimeComponent.YEAR); } )
  | (<KW_MONTH> { result = TimeComponentExtractor.getInstance(
          TimeComponentExtractor.TimeComponent.MONTH); } )
  | (<KW_DAY> { result = TimeComponentExtractor.getInstance(
          TimeComponentExtractor.TimeComponent.DAY); } )
  | (<KW_HOUR> { result = TimeComponentExtractor.getInstance(
          TimeComponentExtractor.TimeComponent.HOUR); } )
  | (<KW_MINUTE> { result = TimeComponentExtractor.getInstance(
          TimeComponentExtractor.TimeComponent.MINUTE); } )
  | (<KW_SECOND> { result = TimeComponentExtractor.getInstance(
          TimeComponentExtractor.TimeComponent.SECOND); } )
  | (<KW_MILLISECOND> { result = TimeComponentExtractor.getInstance(
          TimeComponentExtractor.TimeComponent.MILLISECOND); } )
  | (<KW_NOW> { result = CurrentDateTime.getInstance(); } )
  | (<KW_DATEDIFF> { result = DateDiff.getInstance(); } )
  | (<KW_LOWER> { result = Lower.getInstance(); } )
  | (<KW_UPPER> { result = Upper.getInstance(); } )
  | (<KW_QUARTER> { result = TimeComponentExtractor.getInstance(
          TimeComponentExtractor.TimeComponent.QUARTER); } )
  | (<KW_DAYOFWEEK> { result = TimeComponentExtractor.getInstance(
          TimeComponentExtractor.TimeComponent.DAY_OF_WEEK); } )
  | (<KW_TODATE> { result = ToDate.getInstance(); } ) )
  { return result; }
}

// A single column id. This may be a simple id (e.g. c1), a quoted id
// (e.g. `my column`) or a non-reserved keyword (e.g. max)
String columnId() :
{
  Token t;
  String result = null;
}
{
  ( (t = <ID> { result = t.image; })
  | (t = <QUOTED_ID> { result = ParserUtils.stripQuotes(t.image); })
  | (result = nonReservedKeyword()) )
  { return result; }
}

// A non-reserved keyword (e.g. min)
String nonReservedKeyword() :
{
  Token t;
}
{
  ( t = <KW_MIN>
  | t = <KW_MAX>
  | t = <KW_AVG>
  | t = <KW_COUNT>
  | t = <KW_SUM>
  | t = <KW_NO_VALUES>
  | t = <KW_NO_FORMAT>
  | t = <KW_IS>
  | t = <KW_NULL>
  | t = <KW_YEAR>
  | t = <KW_MONTH>
  | t = <KW_DAY>
  | t = <KW_HOUR>
  | t = <KW_MINUTE>
  | t = <KW_SECOND>
  | t = <KW_MILLISECOND>
  | t = <KW_WITH>
  | t = <KW_CONTAINS>
  | t = <KW_STARTS>
  | t = <KW_ENDS>
  | t = <KW_MATCHES>
  | t = <KW_LIKE>
  | t = <KW_NOW>
  | t = <KW_DATEDIFF>
  | t = <KW_QUARTER>
  | t = <KW_LOWER>
  | t = <KW_UPPER>
  | t = <KW_DAYOFWEEK>
  | t = <KW_TODATE> )
  { return t.image; }
}

// A sort order (e.g., DESC). This can match the empty option and returns
// ASCENDING in that case.
SortOrder sortOrder() :
{}
{
    (<KW_ASC> { return SortOrder.ASCENDING; })
  | (<KW_DESC> { return SortOrder.DESCENDING; })
  | ({ return SortOrder.ASCENDING; }) // empty option
}

// An integer literal (like 4, 0, -3)
int integerLiteral() :
{
  Token t1;
  Token t2;
  String s;
}
{
  ( (t1 = <INTEGER_LITERAL>  { s = t1.image; } )
  | (t1 = <OP_MINUS> t2 = <INTEGER_LITERAL> { s = t1.image + t2.image; } ) )
  { return Integer.parseInt(s); }
}

// A String literal, returned without its surrounding quotes or double quotes.
String stringLiteral() :
{
  Token t;
}
{
  t = <STRING_LITERAL>
  { return ParserUtils.stripQuotes(t.image); }
}

// A decimal (numeric, of type double) literal.
double decimalLiteral() :
{
  Token t1;
  Token t2;
  String s;
}
{
  ( (t1 = <DECIMAL_LITERAL> { s = t1.image; } )
  | (t1 = <INTEGER_LITERAL> {s = t1.image; } )
  | (t1 = <OP_MINUS> ( (t2 = <DECIMAL_LITERAL>) | (t2 = <INTEGER_LITERAL>) )
  { s = t1.image + t2.image; } ) )
  { return Double.parseDouble(s); }
}

// A boolean literal, either true or false.
boolean booleanLiteral() :
{
  boolean b;
}
{
  ( (<KW_TRUE> { b = true; })
  | (<KW_FALSE> { b = false; }) )
  { return b; }
}

// This is to avoid TokenMgrErrors. This will cause a regular parsing exception
// to be thrown when an unexpected char is encountered.
< * > TOKEN :
{
    < UNEXPECTED_CHAR : ~[] >
}
